## ThreadLocal的应用
内部实现
    ThreadLocalMap 
线程污染
对应key为何是虚拟引用
    强
    软 --> 内存不够 GC 就会回收
    弱 --> 堆外内存管理 --> queue
    虚 --> GC 就会回收

什么时候会引起内存泄漏
对象头所占用的字节数
压缩指针

volatile关键字原理、指令重排序引发的DCL问题，

## java内存结构
    堆 - GC
        年轻代
           8 eden
           1 survivor + 1 survivor
        老年代
    栈
    本地方法栈
    本地方法区
    程序计数器

## 栈的组成结构  [https://blog.csdn.net/peanutwzk/article/details/107462027]
    栈帧
        局部变量表
        操作数栈
        动态链接
        返回地址

## GC
### GC 算法
        标记清除
        复制
        标记整理

### GC 收集器

### 逃逸分析
 .java 文件 -- javac --> .class 文件 -- JIT --> 机器指令
 
逃逸分析（Escape Analysis）简单来讲就是，Java Hotspot 虚拟机可以分析新创建对象的使用范围，并决定是否在 Java 堆上分配内存的一项技术
    1、全局逃逸（GlobalEscape）
        即一个对象的作用范围逃出了当前方法或者当前线程，有以下几种场景：

        对象是一个静态变量
        对象是一个已经发生逃逸的对象
        对象作为当前方法的返回值
    2、参数逃逸（ArgEscape）
        即一个对象被作为方法参数传递或者被参数引用，但在调用过程中不会发生全局逃逸，这个状态是通过被调方法的字节码确定的

开启逃逸分析：-XX:+DoEscapeAnalysis
关闭逃逸分析：-XX:-DoEscapeAnalysis
显示分析结果：-XX:+PrintEscapeAnalysis

逃逸分析优化 -- 没有逃逸
当一个对象没有逃逸时，可以得到以下几个虚拟机的优化。
1) 锁消除

我们知道线程同步锁是非常牺牲性能的，当编译器确定当前对象只有当前线程使用，那么就会移除该对象的同步锁。
例如，StringBuffer 和 Vector 都是用 synchronized 修饰线程安全的，但大部分情况下，
它们都只是在当前线程中用到，这样编译器就会优化移除掉这些锁操作。

锁消除的 JVM 参数如下：
开启锁消除：-XX:+EliminateLocks
关闭锁消除：-XX:-EliminateLocks
锁消除在 JDK8 中都是默认开启的，并且锁消除都要建立在逃逸分析的基础上。

2) 标量替换

首先要明白标量和聚合量，基础类型和对象的引用可以理解为标量，它们不能被进一步分解。而能被进一步分解的量就是聚合量，比如：对象。

对象是聚合量，它又可以被进一步分解成标量，将其成员变量分解为分散的变量，这就叫做标量替换。

这样，如果一个对象没有发生逃逸，那压根就不用创建它，只会在栈或者寄存器上创建它用到的成员标量，节省了内存空间，也提升了应用程序性能。

标量替换的 JVM 参数如下：
开启标量替换：-XX:+EliminateAllocations
关闭标量替换：-XX:-EliminateAllocations
显示标量替换详情：-XX:+PrintEliminateAllocations
标量替换同样在 JDK8 中都是默认开启的，并且都要建立在逃逸分析的基础上。

3) 栈上分配
当对象没有发生逃逸时，该对象就可以通过标量替换分解成成员标量分配在栈内存中，和方法的生命周期一致，
随着栈帧出栈时销毁，减少了 GC 压力，提高了应用程序性能


## mysql
### mysql事务隔离级

    读未提交
    读已提交
    可重复读
    串行

### MVCC结构 (多版本并发控制)  
  [https://blog.csdn.net/Waves___/article/details/105295060#1.2%E3%80%81Read%20View%20%E7%BB%93%E6%9E%84]

聚簇索引
非聚簇索引的区别

sql优化

springboot自定义插件
springboot启动过程

## redis
redis数据结构

    String
    List --> Queue
    Set
    Zset
    Hash
    
跳跃表数据结构

    skipList
    
分布式锁优化

钩子进程等

hash冲突
    开放定址法
    再哈希法
    链地址法
    
    
HashMap 链表 树化 过程

key -> 链表节点个数 >= TREEIFY_THRESHOLD(8) - 1
    treeifyBin(tab, hash)
    
    
    

5. 说一下Fordeal消息中心的技术架构
6. 用户反馈消息没收到你会怎么处理？
7. 如果数据全部写入Es可能会导致集群容量不够用，你们是如何设计的？
8. 如果消息丢失，可能会在什么环节丢失的？
9. 消息幂等是怎么做的？
10. 接口定义大概是什么样的
11. 你用过哪些技术栈
12. 你了解Kafka消息投递机制吗
13. 你了解Kafka消息At Least机制是怎么实现的吗
14. Topic和Partition是什么关系
15. 如果Partition数量少于消费者线程数会怎么样
16. 你使用的Kafka参数有哪些？
17. 你用Redis用过哪些数据结构
18. 你Sorted Set的数据结构，SkipList时间复杂度和BTree的时间复杂度怎么样
19. 互动消息大概是怎么样个设计？
20. 资源位的设计是什么样的？


第一题是分转元，写了一个算法，问有什么隐患，没太明白没有做
第二题是，设计一个数据库死锁场景，表字段和索引可以任意设计，需要画出时序图
大概思路:两条记录(一张表或两张表)，两个请求，开始事务，按不同的顺序for update 锁行记录，相互竞争造成死
锁
第=题 10G文件，做过外理，所有标点符号已换成空格，重要找出每个单词的出现次数
大概思路:不能一次读到内存，不然会OOM，用文件流，读一行处理一行，使用多线程处理并考虑线程安全问题考察项目整体架构，自己负责的模块有哪些功能，上下游之间如何交互，一致性问题等
 Java基础，考察jvm内存模型，JMM，volatile，堆的代划分，CMS的执行流程，三色标记算法问了bio和nio区别，zero copy
对MySQL考察比较深入，索引结构，隔离级别，幻读问题，mvcc，buffer pool Spring cloud有哪些核心组件和作用
让面试者说一下自己做比较有成就项目，主要做了什么，面试评估fail。

1、hashmap的实现方式，优缺点，有什么问题?

5、spring mvc请求处理流程?

6、cms垃圾回收器的执行过程，年轻代垃圾回收采用复制算法有什么缺点，怎么改进?

7、程序怎么主动去做垃圾回收?软引用、弱引用、虚引用以及finalize的使用 

8、spring事务实现原理，嵌套事务怎么实现
9、断路器的应用场景
10、限流器的作用
3、apollo配置中心的优缺点
如何保证服务高可用


java 对象布局
    markword(8个字节 64位)  ---> 加锁 修改
    类型指针 
    实例数据 
    对齐padding(补齐 8的倍数 个字节)
    
    
2、aqs的实现方式?

synchronized的使用场景，锁定的对象，升级过程?    
偏向锁
    普通对象 --> 偏向延迟
    匿名偏向
自旋锁 - 轻量级锁
    自适应自旋
锁升级
    重量级锁 --> 自旋次数 || 自选线程数 过多
    
4、volatile的作用，实现原理?

hotspot 反编译
    HSDIS
    
    
    
    Zset 

